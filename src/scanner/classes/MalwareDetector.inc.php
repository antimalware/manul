<?php

require_once("XmlValidator.inc.php");
require_once ("FileInfo.inc.php");
require_once("Writer.inc.php");
require_once("Quarantiner.inc.php");

session_start();

function escapedHexToHex($escaped) { 
   return chr(hexdec($escaped[1])); 
}

session_start();
function escapedOctDec($escaped) { 
   return chr(octdec($escaped[1])); 
}

class MalwareDetector {
    function __construct() {
        global $project_root_dir, $project_tmp_dir;

        $this->SIGNATURE_FILENAME = $project_root_dir . '/static/signatures/malware_db.xml';

        $this->QUEUE_FILENAME = $project_tmp_dir . '/scan_queue.manul.tmp.txt';
        $this->QUEUE_OFFSET_FILENAME = $project_tmp_dir . '/queue_offset.manul.tmp.txt';
        $this->MALWARE_LOG_FILENAME = $project_tmp_dir . '/malware_log.manul.tmp.txt';
        $this->MALWARE_QUARANTINE_FILENAME = $project_tmp_dir . '/malware_quarantine.manul.tmp.txt';

        $this->XML_LOG_FILENAME = $project_tmp_dir . '/scan_log.xml';	
        
        $this->SCRIPT_START = time();

        $this->MAX_FILESIZE = 1 * 1024 * 1024; // 1MB
        $this->MAX_PREVIEW_LENGTH = 80; // characters
        $this->MAX_EXECUTION_DURATION = 20;

    	$validator = new XmlValidator();
    	if (!$validator->validate(implode('', file($this->SIGNATURE_FILENAME)), $project_root_dir .'/static/xsd/malware_db.xsd')) {
	    	die(basename(__FILE__) . PS_ERR_MALWARE_DB_BROKEN);
    	}

        $this->signatures = new DOMDocument();
        $this->signatures->load($this->SIGNATURE_FILENAME);
    }

    function setRequestDelay($delay) {
        $this->MAX_EXECUTION_DURATION = $delay;    
    }

    function throwTimeout() {
        echo $this->AJAX_HEADER_ERROR . "\n";
        echo basename(__FILE__) . ": timeout. Try to increase an interval in settings.\n";
        exit;
    }

    function normalizeContent($content) {
        $content = preg_replace_callback('/\\\\x([a-fA-F0-9]{1,2})/i', 'escapedHexToHex', $content); // strip hex ascii notation
        $content = preg_replace_callback('/\\\\([0-9]{1,3})/i', 'escapedOctDec', $content); // strip dec ascii notation
        $content = preg_replace('/[\'"]\s*?\.\s*?[\'"]/smi', '', $content); // concat fragmented strings
	$content = preg_replace('|/\*.*?\*/|smi', '', $content); // remove comments to detect fragmented pieces of malware

        return $content;
    }

    function getFragment($content, $pos) {
       $max_chars = $this->MAX_PREVIEW_LENGTH;
       $max_len = strlen($content);
       $right_pos = min($pos + $max_chars, $max_len); 
       $min_pos = max(0, $pos - $max_chars);

       $start = substr($content, 0, $pos);
       $start = str_replace("\r", '', $start);
       $line_no = strlen($start) - strlen(str_replace("\n", '', $start)) + 1;

       $res = 'L' . $line_no . ': ' . substr($content, $min_pos, $pos - $min_pos) . 
           '@_MARKER_@' . 
           substr($content, $pos, $right_pos - $pos - 1);

        return htmlspecialchars($res);
    }

    function queueQuarantine($filename) {
        if ($fh = fopen($this->MALWARE_QUARANTINE_FILENAME, "a")) {
           fputs($fh, $filename . "\n");
           fclose($fh);
        }
    }

    function detectMalware($file_path, &$found_fragment, &$pos, $start_time, $timeout) {

        if (filesize($file_path) > $this->MAX_FILESIZE) {
           return "skipped";
        }

        if (!is_file($file_path)) {
           return "no_read";
        }

        
        $content = implode("", file($file_path));
        $normalized = $this->normalizeContent($content);

        $db = $this->signatures->getElementsByTagName('signature');
        $detected = false;
                foreach ($db as $sig) {
           if ($detected) break;

           $cur_time = time();
           if ($cur_time - $start_time > $timeout) {
              return "timeout";
           }      

           $pos = -1;
           $sig_content = $sig->nodeValue;
           $attr = $sig->attributes;
           $attr_id = $attr->getNamedItem("id")->nodeValue;
           $attr_format = $attr->getNamedItem("format")->nodeValue;
           $attr_child_id = $attr->getNamedItem("child_id")->nodeValue;
           $attr_severity = $attr->getNamedItem("sever")->nodeValue;

           switch ($attr_format) {

              case 're': 
                         if ((preg_match('#(' . $sig_content . ')#smi', $content, $found, PREG_OFFSET_CAPTURE)) ||
                             (preg_match('#(' . $sig_content . ')#smi', $normalized, $found, PREG_OFFSET_CAPTURE))) 
                         {
                            $detected = true;
                            $pos = $found[0][1];
                            continue;
                         }

                         break;
              case 'const': 
                         if ((($pos = strpos($content, $sig_content)) !== FALSE) || 
                             (($pos = strpos($normalized, $sig_content)) !== FALSE))
                         {
                            $detected = true;
                            continue;
                         }

                         break;
           }
        }

        if ($detected) {
           $found_fragment = $this->getFragment($content, $pos);
           return $attr_severity;
        }
    }


    function parseXml($xml_filename) {
        $dom;
        try {
            $dom = new DOMDocument("1.0", "utf-8");
            $dom->formatOutput = true; 
            $dom->load($xml_filename);
        }
        catch(Exception $e) {
            die("An exception has occured: " . $e->getMessage() . "\n");
        }
        if (!$dom) {
            die("An exception has occured: ");
        }
        return $dom;
    }



    function repackXMLLog() {     
        global $project_root_dir;    

        $xml_log_filename = $this->XML_LOG_FILENAME;
        $xml = $this->parseXml($xml_log_filename);
        $xpath = new DOMXpath($xml); 

        if (!is_file($this->MALWARE_LOG_FILENAME)) {
            die(basename(__FILE__) . ': cannot open ' . $this->MALWARE_LOG_FILENAME . ' during repacking');
        }

        $lines = file($this->MALWARE_LOG_FILENAME);

        foreach($lines as $line_num => $line)
        {   
            #Example /home/www/badcode.tk/web_root/robots.txt.dist;detected=;pos=-1;snippet=
            $data = explode(';', $line);
            $file_path = $data[0];
            $detected = substr($data[1], strlen('detected='));
            if ($detected)
            {
                $pos = substr($data[2], strlen('pos='));
                $snippet = substr($data[3], strlen('snippet='));

                #Getting current element in DOM
                $relative_path = str_replace(dirname($project_root_dir), '.', $file_path);                                
                $file_path_node = $xpath->query('/website_info/files/file/path[text()="' . $relative_path . '"]')->item(0);
                $fileinfo_node = $file_path_node->parentNode;
               
                #Adding detection info to DOM
                $fileinfo_node->setAttribute("detected", $detected);
                $fileinfo_node->setAttribute("snippet", $snippet);
                $fileinfo_node->setAttribute("pos", $pos);

            }
        }

        $xml->save($xml_log_filename);

        return $xml->saveXML();
             
    }

    function buildQuarantineArchive() {
       if (file_exists($this->MALWARE_QUARANTINE_FILENAME)) {
          $list = file($this->MALWARE_QUARANTINE_FILENAME);

          if (count($list) > 0) {
             $quarantiner = new Quarantiner();
             foreach ($list as $filename) {
                $quarantiner->add(trim($filename));
             }

             return $quarantiner->getArchive();          
          }
       }

       return null;
    }

    function finishMalwareScan() {
        global $php_errormsg;         

        $xml = $this->repackXMLLog();


        @unlink($this->MALWARE_LOG_FILENAME);
        @unlink($this->QUEUE_OFFSET_FILENAME);
        @unlink($this->QUEUE_FILENAME);

	$_SESSION['qarc_filename'] = $this->buildQuarantineArchive();	            
        @unlink($this->MALWARE_QUARANTINE_FILENAME);

        $result = json_encode(array('type' => 'getSignatureScanResult', 'status' => 'finished', 'phpError' => $php_errormsg)); 
        return $result;
    }

    function malwareScanRound() {

        global $php_errormsg;         
       
        $time_of_start = time();

        if (!is_file($this->QUEUE_FILENAME)) {
            die(basename(__FILE__) . ': cannot open ' . $this->QUEUE_FILENAME . ' on scan round');
        }

        $fh = fopen($this->QUEUE_FILENAME, 'r');
        $offset = 0;

        if (file_exists($this->QUEUE_OFFSET_FILENAME))  {            
            $offset = (int) file_get_contents($this->QUEUE_OFFSET_FILENAME);            
            fseek($fh, $offset);
        }


        if (filesize($this->QUEUE_FILENAME) - $offset <= 0) {            
            fclose($fh);
            return $this->finishMalwareScan(); 
        }

               
        $queueText = fread($fh, filesize($this->QUEUE_FILENAME) - $offset);
        $queueLines = explode("\n", $queueText);

        $num_files_scanned = 0;

        if (count($queueLines) < 1) {            
            fclose($fh);
            return $this->finishMalwareScan(); 
        }
       
        foreach($queueLines as $line)
        {
            $execution_time = time() - $time_of_start;
            if ($execution_time >= round($this->MAX_EXECUTION_DURATION * 0.8)) {                 
                break;   
            } else if (empty($line)) {
                continue;
            }

            $offset += strlen($line) + 1; 

            $fileinfo = explode(" ", $line);

            $file_path = $fileinfo[0];
            $file_hash = $fileinfo[1];           

            $snippet = '';
            $file_extension = pathinfo(basename($file_path), PATHINFO_EXTENSION);
                        
            $res = $this->detectMalware($file_path, $snippet, $pos, $this->SCRIPT_START, $this->MAX_EXECUTION_DURATION);
            switch ($res) {         
                case "no_read":
                   break;
                case "skipped":
                   break;
                case "timeout":
                    file_put_contents2($this->QUEUE_OFFSET_FILENAME, $offset);
                    $this->throwTimeout();
                    break;
                default:                    
                    $num_files_scanned++;
                    $content = $file_path . ";detected=" . $res . ';pos=' . $pos . ';snippet=' . base64_encode($snippet) . PHP_EOL;  
                    file_put_contents2($this->MALWARE_LOG_FILENAME, $content, 'a');

                    if ($res) {
                       $this->queueQuarantine($file_path);
                    }

            }            
           
        }

        file_put_contents2($this->QUEUE_OFFSET_FILENAME, $offset);
        fclose($fh);
               
        if (count($queueLines) <= 1) {
            return $this->finishMalwareScan();
        } 
            
        $data = array('filesScannedThisTime' => $num_files_scanned, 'filesLeft' => count($queueLines), 'lastFile' => $file_path);        
        $result = json_encode(array('type' => 'getSignatureScanResult', 'status' => 'inProcess', 'data' => $data, 'phpError' => $php_errormsg));
        return $result;
    
    }      


} // End of class
